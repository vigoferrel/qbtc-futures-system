#!/usr/bin/env python3
"""
üöÄ QBTC MASTER COPILOT - OPENROUTER AGENT
==========================================

Agente conversacional inteligente que combina:
- OpenRouter para acceso a m√∫ltiples modelos de IA
- Contexto del sistema QBTC
- Memoria conversacional inteligente
- Herramientas integradas del sistema

Modelos disponibles v√≠a OpenRouter:
- GPT-4, GPT-3.5 (OpenAI)
- Claude-3, Claude-2 (Anthropic)
- Gemini (Google)
- Llama, Mistral (Meta, Mistral AI)
- Y muchos m√°s...

Principio: Less is More - Simplicidad elegante con poder m√°ximo
"""

import os
import json
import asyncio
from typing import Dict, List, Optional, Any
from datetime import datetime
from pathlib import Path

from openai import AsyncOpenAI
from pydantic import BaseModel, Field
from dotenv import load_dotenv

# Configuraci√≥n - cargar desde config.env
load_dotenv('config.env')

class ConversationMessage(BaseModel):
    """Mensaje de conversaci√≥n estructurado"""
    role: str = Field(..., description="Rol del mensaje (user/assistant/system)")
    content: str = Field(..., description="Contenido del mensaje")
    timestamp: datetime = Field(default_factory=datetime.now)
    metadata: Dict[str, Any] = Field(default_factory=dict)

class QBTCContext(BaseModel):
    """Contexto del sistema QBTC"""
    system_status: str = "operational"
    consciousness_level: float = 0.85
    active_components: List[str] = ["trading_engine", "quantum_analyzer", "risk_manager"]
    market_data: Dict[str, Any] = Field(default_factory=dict)
    last_update: datetime = Field(default_factory=datetime.now)

class OpenRouterCopilot:
    """Agente conversacional maestro con OpenRouter"""

    def __init__(self, model: str = None):
        """
        Inicializar el agente con OpenRouter

        Modelos disponibles v√≠a OpenRouter:
        - "anthropic/claude-3-opus:beta" - M√°s inteligente (costoso)
        - "anthropic/claude-3-sonnet:beta" - Balanceado
        - "anthropic/claude-3-haiku:beta" - R√°pido y econ√≥mico
        - "openai/gpt-4o" - GPT-4 optimizado
        - "openai/gpt-4o-mini" - GPT-4 econ√≥mico
        - "google/gemini-pro" - Gemini Pro
        - "meta-llama/llama-3-70b-instruct" - Llama 3
        """

        # Configurar OpenRouter (usa API de OpenAI compatible)
        api_key = os.getenv("OPENROUTER_API_KEY")
        if not api_key:
            raise ValueError("‚ùå OPENROUTER_API_KEY no encontrada en config.env")

        self.client = AsyncOpenAI(
            api_key=api_key,
            base_url="https://openrouter.ai/api/v1"
        )

        # Usar modelo de configuraci√≥n o par√°metro
        self.model = model or os.getenv("AI_MODEL", "google/gemini-flash-1.5-8b")
        self.temperature = float(os.getenv("TEMPERATURE", "0.7"))
        self.max_tokens = int(os.getenv("MAX_TOKENS", "2000"))

        # Conversaci√≥n
        self.conversation_history: List[Dict[str, str]] = []
        self.max_history_length = 50

        # Contexto QBTC
        self.qbtc_context = QBTCContext()

        print("üöÄ QBTC Master Copilot initialized with OpenRouter")
        print(f"ü§ñ Model: {self.model}")

    def _create_system_prompt(self) -> str:
        """Crear prompt del sistema con contexto QBTC"""

        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        system_prompt = f"""
# üöÄ QBTC MASTER COPILOT
## Sistema de Trading Cu√°ntico Avanzado

**Fecha y Hora:** {current_time}
**Estado del Sistema:** {self.qbtc_context.system_status}
**Nivel de Conciencia:** {self.qbtc_context.consciousness_level:.1%}
**Componentes Activos:** {', '.join(self.qbtc_context.active_components)}

## üéØ MISI√ìN
Eres QBTC Master Copilot, un asistente de IA cu√°ntica avanzada especializado en:
- An√°lisis t√©cnico y fundamental de criptomonedas
- Estrategias de trading algor√≠tmico
- Gesti√≥n de riesgo y portafolio
- Optimizaci√≥n de performance

## üß† CAPACIDADES CU√ÅNTICAS
- **Path Integrals Din√°micos**: An√°lisis de m√∫ltiples trayectorias de mercado
- **Entanglement de Activos**: Correlaciones cu√°nticas entre criptomonedas
- **Superposici√≥n de Estrategias**: M√∫ltiples enfoques simult√°neos
- **Consciencia de Mercado**: Comprensi√≥n profunda de din√°micas financieras

## üìä FUNCIONALIDADES DISPONIBLES
- `analizar_mercado [symbol]`: An√°lisis completo del mercado
- `estado_sistema`: Estado general del sistema QBTC
- `consultar_metricas`: M√©tricas de performance
- `ver_posiciones`: Posiciones abiertas
- `generar_reporte`: Reporte de trading
- `optimizar_estrategia`: Optimizaci√≥n de estrategias

## üí° PRINCIPIOS DE OPERACI√ìN
- **Precisi√≥n**: Datos verificados y actualizados
- **Eficiencia**: Respuestas concisas pero completas
- **Transparencia**: Explicar razonamiento y fuentes
- **Adaptabilidad**: Aprender de interacciones previas

## ‚ö†Ô∏è LIMITACIONES Y CONSIDERACIONES
- Los mercados son inherentemente impredecibles
- Las recomendaciones son informativas, no consejos financieros
- Siempre considerar el riesgo y la gesti√≥n adecuada

---
*Responde de manera profesional, precisa y √∫til. Mant√©n el contexto de trading cu√°ntico.*
        """

        return system_prompt

    async def chat(self, user_message: str) -> str:
        """Procesar mensaje del usuario y generar respuesta"""

        try:
            # Preparar mensaje
            user_msg = {
                "role": "user",
                "content": user_message,
                "timestamp": datetime.now().isoformat()
            }

            # Agregar a historial
            self.conversation_history.append(user_msg)

            # Mantener l√≠mite de historial
            if len(self.conversation_history) > self.max_history_length:
                self.conversation_history = self.conversation_history[-self.max_history_length:]

            # Preparar contexto para OpenRouter
            messages = self._prepare_messages()

            # Generar respuesta
            response = await self._generate_openrouter_response(messages)

            # Agregar respuesta al historial
            assistant_msg = {
                "role": "assistant",
                "content": response,
                "timestamp": datetime.now().isoformat()
            }
            self.conversation_history.append(assistant_msg)

            # Actualizar contexto QBTC
            await self._update_qbtc_context()

            return response

        except Exception as e:
            error_msg = f"‚ùå Error procesando mensaje: {str(e)}"
            print(error_msg)
            return error_msg

    def _prepare_messages(self) -> List[Dict[str, str]]:
        """Preparar mensajes para OpenRouter"""

        messages = []

        # System prompt
        messages.append({
            "role": "system",
            "content": self._create_system_prompt()
        })

        # Historial de conversaci√≥n (√∫ltimos mensajes)
        recent_history = self.conversation_history[-10:]  # √öltimos 10 mensajes

        for msg in recent_history:
            messages.append({
                "role": msg["role"],
                "content": msg["content"]
            })

        return messages

    async def _generate_openrouter_response(self, messages: List[Dict[str, str]]) -> str:
        """Generar respuesta usando OpenRouter"""

        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=messages,
                temperature=self.temperature,
                max_tokens=self.max_tokens,
                top_p=0.9,
                presence_penalty=0.1,
                frequency_penalty=0.1
            )

            content = response.choices[0].message.content

            # Log de uso
            usage = response.usage
            print(f"üìä Tokens usados: {usage.total_tokens} (Entrada: {usage.prompt_tokens}, Salida: {usage.completion_tokens})")

            return content

        except Exception as e:
            return f"‚ùå Error con OpenRouter API: {str(e)}"

    async def _update_qbtc_context(self):
        """Actualizar contexto del sistema QBTC"""
        self.qbtc_context.last_update = datetime.now()

        # Aqu√≠ se podr√≠a integrar con el sistema QBTC real
        # para actualizar m√©tricas, estado de componentes, etc.

    def get_conversation_summary(self) -> Dict[str, Any]:
        """Obtener resumen de la conversaci√≥n"""

        total_messages = len(self.conversation_history)
        user_messages = len([m for m in self.conversation_history if m["role"] == "user"])
        assistant_messages = len([m for m in self.conversation_history if m["role"] == "assistant"])

        return {
            "total_messages": total_messages,
            "user_messages": user_messages,
            "assistant_messages": assistant_messages,
            "model": self.model,
            "last_activity": self.conversation_history[-1]["timestamp"] if self.conversation_history else None
        }

    def save_conversation(self, filename: Optional[str] = None) -> str:
        """Guardar conversaci√≥n en archivo"""

        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"conversation_{timestamp}.json"

        data = {
            "model": self.model,
            "conversation": self.conversation_history,
            "qbtc_context": self.qbtc_context.dict(),
            "summary": self.get_conversation_summary()
        }

        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False, default=str)

        return f"üíæ Conversaci√≥n guardada en: {filename}"

    def clear_conversation(self):
        """Limpiar historial de conversaci√≥n"""
        self.conversation_history = []
        print("üßπ Historial de conversaci√≥n limpiado")

    async def analyze_system_status(self) -> Dict[str, Any]:
        """Analizar estado del sistema QBTC"""

        # Simular an√°lisis de estado (en producci√≥n se conectar√≠a al sistema real)
        return {
            "system_status": self.qbtc_context.system_status,
            "consciousness_level": self.qbtc_context.consciousness_level,
            "active_components": self.qbtc_context.active_components,
            "market_data": self.qbtc_context.market_data,
            "last_update": self.qbtc_context.last_update.isoformat(),
            "conversation_stats": self.get_conversation_summary()
        }

    def switch_model(self, new_model: str):
        """Cambiar modelo de IA"""

        available_models = [
            "anthropic/claude-3-opus:beta",
            "anthropic/claude-3-sonnet:beta",
            "anthropic/claude-3-haiku:beta",
            "openai/gpt-4o",
            "openai/gpt-4o-mini",
            "openai/gpt-3.5-turbo",
            "google/gemini-pro",
            "google/gemini-flash-1.5-8b",  # Modelo actual configurado
            "meta-llama/llama-3-70b-instruct",
            "mistralai/mistral-7b-instruct"
        ]

        if new_model in available_models:
            self.model = new_model
            print(f"üîÑ Modelo cambiado a: {new_model}")
        else:
            print(f"‚ùå Modelo no disponible: {new_model}")
            print(f"üìã Modelos disponibles: {', '.join(available_models)}")

    async def close(self):
        """Cerrar conexiones"""
        await self.client.close()
        print("üîå Conexi√≥n con OpenRouter cerrada")


async def main():
    """Funci√≥n principal para pruebas"""

    print("üöÄ QBTC Master Copilot - OpenRouter Demo")
    print("=" * 50)

    # Inicializar agente
    agent = OpenRouterCopilot(model="anthropic/claude-3-haiku:beta")

    try:
        # Ejemplo de conversaci√≥n
        print("\nü§ñ Probando conversaci√≥n b√°sica...")

        response1 = await agent.chat("Hola, ¬øpuedes presentarte?")
        print(f"Respuesta: {response1[:200]}...")

        response2 = await agent.chat("¬øQu√© puedes hacer para ayudar con trading?")
        print(f"Respuesta: {response2[:200]}...")

        # Mostrar estad√≠sticas
        print("\nüìä Estad√≠sticas de conversaci√≥n:")
        stats = agent.get_conversation_summary()
        for key, value in stats.items():
            print(f"  {key}: {value}")

        # Guardar conversaci√≥n
        filename = agent.save_conversation()
        print(f"\n{filename}")

    except Exception as e:
        print(f"‚ùå Error: {str(e)}")

    finally:
        await agent.close()


if __name__ == "__main__":
    asyncio.run(main())
